/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int j___setdefaultprecision(void); // weak
int __cdecl j___setargv(); // idb
void __fastcall __security_check_cookie(unsigned int cookie); // idb
void __cdecl j___RTC_Terminate(); // idb
int (*__cdecl _RTC_GetErrorFuncW(const void *addr))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
int j____security_init_cookie(void); // weak
int __cdecl j__atexit(void (__cdecl *func)()); // idb
int __cdecl j___lock(_DWORD); // weak
void __cdecl terminate(); // idb
int __cdecl j___initterm(_DWORD, _DWORD); // weak
_IMAGE_SECTION_HEADER *__cdecl j___FindPESection(char *pImageBase, unsigned int rva); // idb
void __cdecl _RTC_StackFailure(void *retaddr, const char *varname); // idb
int __cdecl j___crt_debugger_hook(_DWORD); // weak
int __cdecl j___ValidateImageBase(char *pImageBase); // idb
int (*__cdecl j___RTC_SetErrorFuncW(int (*func)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
int (__cdecl *__cdecl j___onexit(int (__cdecl *func)()))(); // idb
_TEB *__cdecl j__NtCurrentTeb(); // idb
void __cdecl j___invoke_watson_if_error(int _ExpressionError, const wchar_t *_Expression, const wchar_t *_Function, const wchar_t *_File, unsigned int _Line, unsigned int _Reserved); // idb
int __stdcall __CxxUnhandledExceptionFilter(_EXCEPTION_POINTERS *pPtrs); // idb
int __cdecl j___unlock(_DWORD); // weak
int __cdecl j__main(); // idb
int j___RTC_Initialize(void); // weak
errno_t __cdecl j___controlfp_s(unsigned int *CurrentState, unsigned int NewValue, unsigned int Mask);
int __cdecl j___invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl _RTC_GetSrcLine(char *address, wchar_t *source, unsigned int sourcelen, int *pline, wchar_t *moduleName, unsigned int modulelen); // idb
int __cdecl j___CRT_RTC_INITW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j___IsNonwritableInCurrentImage(char *pTarget); // idb
int __cdecl j___amsg_exit(_DWORD); // weak
int __cdecl j___except_handler4_common(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j___matherr(_exception *pexcept); // idb
void __cdecl _RTC_Failure(void *retaddr, int errnum); // idb
void __cdecl _RTC_AllocaFailure(void *retaddr, _RTC_ALLOCA_NODE *pn, int num); // idb
int __stdcall j____dllonexit(_DWORD); // weak
int __cdecl j___initterm_e(_DWORD, _DWORD); // weak
int (*__cdecl _RTC_GetErrorFunc(const void *addr))(int, const char *, int, const char *, const char *, ...); // idb
int __cdecl main(); // idb
// int __usercall _RTC_CheckEsp@<eax>(char a1@<zf>, int result@<eax>);
void __fastcall _RTC_CheckStackVars(void *frame, _RTC_framedesc *v); // idb
void __fastcall _RTC_CheckStackVars2(void *frame, _RTC_framedesc *v, _RTC_ALLOCA_NODE *allocaList); // idb
void _RTC_InitBase();
int _RTC_Shutdown();
int __cdecl pre_c_init(); // idb
int pre_cpp_init();
int __cdecl mainCRTStartup(); // idb
int __cdecl _tmainCRTStartup(); // idb
_TEB *__cdecl NtCurrentTeb(); // idb
int __cdecl check_managed_app(); // idb
void __cdecl _RTC_Failure(void *retaddr, int errnum); // idb
void __cdecl failwithmessage(void *retaddr, int crttype, int errnum, const char *msg); // idb
int __cdecl DebuggerProbe(unsigned int dwLevelRequired); // idb
int __cdecl DebuggerRuntime(unsigned int dwErrorNumber, int bRealBug, void *pvReturnAddr, const wchar_t *pwMessage); // idb
void __cdecl _RTC_StackFailure(void *retaddr, const char *varname); // idb
void __cdecl _RTC_AllocaFailure(void *retaddr, _RTC_ALLOCA_NODE *pn, int num); // idb
void __cdecl getMemBlockDataString(char *printbuff, char *valbuff, char *data, unsigned int datasize); // idb
void __cdecl _RTC_UninitUse(const char *varname); // idb
int __cdecl _RTC_NumErrors(); // idb
const char *__cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum); // idb
int __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int type); // idb
int (*__cdecl _RTC_SetErrorFunc(int (*func)(int, const char *, int, const char *, const char *, ...)))(int, const char *, int, const char *, const char *, ...); // idb
int (*__cdecl _RTC_SetErrorFuncW(int (*func)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
int (*__cdecl _RTC_GetErrorFunc())(int, const char *, int, const char *, const char *, ...);
int (*__cdecl _RTC_GetErrorFuncW())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...);
int __stdcall __CxxUnhandledExceptionFilter(_EXCEPTION_POINTERS *pPtrs); // idb
int __cdecl __CxxSetUnhandledExceptionFilter(); // idb
void _setdefaultprecision();
void __cdecl _invoke_watson_if_error(int _ExpressionError, const wchar_t *_Expression, const wchar_t *_Function, const wchar_t *_File, unsigned int _Line, unsigned int _Reserved); // idb
int __cdecl _matherr();
int __cdecl _setargv(); // idb
int (*_RTC_Initialize())(void);
int (*_RTC_Terminate())(void);
int (__cdecl *__cdecl _onexit(int (__cdecl *func)()))(); // idb
int __cdecl atexit(void (__cdecl *func)()); // idb
unsigned int __security_init_cookie();
int __cdecl _ValidateImageBase(char *pImageBase); // idb
_IMAGE_SECTION_HEADER *__cdecl _FindPESection(char *pImageBase, unsigned int rva); // idb
int __cdecl _IsNonwritableInCurrentImage(char *pTarget); // idb
int __cdecl _except_handler4(_EXCEPTION_RECORD *ExceptionRecord, _EXCEPTION_REGISTRATION_RECORD *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext);
int __cdecl _RTC_GetSrcLine(char *address, wchar_t *source, unsigned int sourcelen, int *pline, wchar_t *moduleName, unsigned int modulelen); // idb
HINSTANCE__ *__cdecl GetPdbDll(); // idb
// BOOL __usercall __noreturn __report_gsfailure@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4@<ebx>, unsigned int a5@<edi>, unsigned int a6@<esi>, char a7);
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// void __stdcall Sleep(DWORD dwMilliseconds);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// HANDLE __stdcall GetProcessHeap();
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// DWORD __stdcall GetCurrentProcessId();
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetTickCount();
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// PVOID __stdcall DecodePointer(PVOID Ptr);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// int __stdcall lstrlenA(LPCSTR lpString);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall IsDebuggerPresent();
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// BOOL __stdcall HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);
// LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination, LONG Exchange, LONG Comperand);
// PVOID __stdcall EncodePointer(PVOID Ptr);
// int __thiscall std::basic_ostream<char,std::char_traits<char>>::operator<<(_DWORD, _DWORD, _DWORD); weak
// _onexit_t __cdecl __onexit(_onexit_t Func);
// int __cdecl __CrtDbgReportW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __CrtSetCheckCount(_DWORD); weak
// void __cdecl __noreturn _exit(int Code);
// void __cdecl __cexit();
// int __cdecl ___getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl ___set_app_type(_DWORD); weak
// int __cdecl ___setusermatherr(_DWORD); weak
// int __cdecl __configthreadlocale(_DWORD); weak
// int __cdecl _getchar();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN __xc_a; // weak
_UNKNOWN __xc_z; // weak
_UNKNOWN __xi_a; // weak
_UNKNOWN __xi_z; // weak
const char *const RTC_ErrorMessages[6] =
{
  "The value of ESP was not properly saved across a function call.  This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different calling convention.\n\r",
  "A cast to a smaller data type has caused a loss of data.  If this was intentional, you should mask the source of the cast with the appropriate bitmask.  For example:  \n\r\tchar c = (i & 0xFF);\n\rChanging the code in this way will not affect the quality of the resulting optimized code.\n\r",
  "Stack memory was corrupted\n\r",
  "A local variable was used before it was initialized\n\r",
  "Stack memory around _alloca was corrupted\n\r",
  "Unknown Runtime Check Error\n\r"
}; // idb
const int RTC_NoFalsePositives[6] = { 1, 0, 1, 1, 1, 1 }; // idb
char stack_premsg[28] = "Stack around the variable '"; // idb
char uninit_premsg[15] = "The variable '"; // idb
const char *const RTC_errlist[5] =
{
  "Stack pointer corruption",
  "Cast to smaller type causing loss of data",
  "Stack memory corruption",
  "Local variable used before initialization",
  "Stack around _alloca corrupted"
}; // idb
const wchar_t mspdbName[13] = { 77u, 83u, 80u, 68u, 66u, 49u, 48u, 48u, 46u, 68u, 76u, 76u, 0u }; // idb
_EXCEPTION_POINTERS GS_ExceptionPointers = { &GS_ExceptionRecord, &GS_ContextRecord }; // idb
_UNKNOWN unk_416660; // weak
_UNKNOWN __rtc_izz; // weak
_UNKNOWN unk_41696C; // weak
_UNKNOWN __rtc_tzz; // weak
int _RTC_ErrorLevels = 1; // idb
int crttype = 1; // idb
int dword_41700C = 1; // idb
int dword_417010 = 1; // idb
int __globallocalestatus = 4294967294; // weak
int __defaultmatherr = 1; // weak
int __security_cookie = 3141592654; // weak
int __security_cookie_complement = 1153374641; // weak
bool init = false; // idb
int argc = 0; // idb
char **envp = NULL; // idb
char **argv = NULL; // idb
int managedapp = 0; // idb
int argret = 0; // idb
_startupinfo startinfo = { 0 }; // idb
int mainret = 0; // idb
int has_cctor = 0; // idb
int (*wsprintffp)(char *, const char *, ...) = NULL; // weak
int (*RTC_ErrorReportFunc)(int, const char *, int, const char *, const char *, ...) = NULL; // idb
int (*RTC_ErrorReportFuncW)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...) = NULL; // idb
int _commode = 0; // weak
int _fmode = 0;
int _dowildcard = 0; // weak
int _newmode = 0; // weak
HINSTANCE__ *mspdb = NULL; // idb
bool PDBOK = false; // idb
bool alreadyTried = false; // idb
_EXCEPTION_RECORD GS_ExceptionRecord =
{
  0,
  0u,
  NULL,
  NULL,
  0u,
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
}; // idb
int DebuggerWasPresent = 0; // idb
_CONTEXT GS_ContextRecord = { 0u, 0u, 0u, 0u, 0u, 0u,  }; // idb
int __native_startup_state; // weak
volatile LONG __native_startup_lock; // idb
PVOID __onexitend; // idb
PVOID __onexitbegin; // idb
int _NoHeapEnableTerminationOnCorruption; // weak
char __dyn_tls_init_callback[]; // idb
// extern _UNKNOWN std::cout; weak
// extern _UNKNOWN ___initenv; weak
// extern int __fmode;
// extern _UNKNOWN __commode; weak


//----- (00411390) --------------------------------------------------------
int __cdecl main()
{
  char v1; // [sp+14h] [bp-F8h]@1
  int n; // [sp+D8h] [bp-34h]@1
  int x; // [sp+E4h] [bp-28h]@1
  long double i; // [sp+F0h] [bp-1Ch]@1
  long double pi; // [sp+100h] [bp-Ch]@1

  memset(&v1, 0xCCu, 0xF8u);
  pi = 4.0;
  i = 1.0;
  x = 1;
  for ( n = 1; n <= 5000000; ++n )
  {
    i = i + 2.0;
    x = -x;
    pi = 4.0 / ((double)x * i) + pi;
  }
  std::basic_ostream<char,std::char_traits<char>>::operator<<(std::cout, LODWORD(pi), HIDWORD(pi));
  _getchar();
  _getchar();
  return 0;
}
// 418290: using guessed type int __thiscall std::basic_ostream<char,std::char_traits<char>>::operator<<(_DWORD, _DWORD, _DWORD);

//----- (004114A0) --------------------------------------------------------
int __usercall _RTC_CheckEsp@<eax>(char a1@<zf>, int result@<eax>)
{
  int v2; // ST18_4@2
  void *_0; // [sp+0h] [bp+0h]@2

  if ( !a1 )
  {
    v2 = result;
    _RTC_Failure(_0, 0);
    result = v2;
  }
  return result;
}

//----- (004114D0) --------------------------------------------------------
void __fastcall _RTC_CheckStackVars(void *frame, _RTC_framedesc *v)
{
  int v2; // edi@1
  _RTC_framedesc *v3; // esi@1
  char *v4; // ebx@1
  _RTC_vardesc *v5; // eax@2
  int v6; // ecx@2
  int i; // [sp+Ch] [bp-4h]@1
  void *retaddr; // [sp+14h] [bp+4h]@4

  v2 = 0;
  v3 = v;
  v4 = (char *)frame;
  for ( i = 0; i < v3->varCount; ++i )
  {
    v5 = v3->variables;
    v6 = v5[v2].addr;
    if ( *(_DWORD *)&v4[v6 - 4] != -858993460 || *(_DWORD *)(&v4[v6] + v5[v2].size) != -858993460 )
      _RTC_StackFailure(retaddr, v5[v2].name);
    ++v2;
  }
}

//----- (00411590) --------------------------------------------------------
void __fastcall _RTC_CheckStackVars2(void *frame, _RTC_framedesc *v, _RTC_ALLOCA_NODE *allocaList)
{
  _RTC_framedesc *v3; // esi@1
  int v4; // edi@1
  char *v5; // ebx@1
  _RTC_vardesc *v6; // eax@3
  int v7; // ecx@3
  _RTC_ALLOCA_NODE *v8; // esi@7
  int v9; // edi@7
  _RTC_ALLOCA_NODE *v10; // eax@7
  int i; // [sp+Ch] [bp-4h]@2
  void *retaddr; // [sp+14h] [bp+4h]@5

  v3 = v;
  v4 = 0;
  v5 = (char *)frame;
  if ( v )
  {
    i = 0;
    if ( v->varCount > 0 )
    {
      do
      {
        v6 = v3->variables;
        v7 = v6[v4].addr;
        if ( *(_DWORD *)&v5[v7 - 4] != -858993460 || *(_DWORD *)(&v5[v7] + v6[v4].size) != -858993460 )
          _RTC_StackFailure(retaddr, v3->variables[v4].name);
        ++v4;
        ++i;
      }
      while ( i < v3->varCount );
    }
  }
  v8 = allocaList;
  v9 = 0;
  v10 = allocaList;
  if ( allocaList )
  {
    do
    {
      v10 = v10->next;
      ++v9;
    }
    while ( v10 );
    if ( allocaList )
    {
      do
      {
        if ( v8->guard1 != -858993460
          || v8->guard2[0] != -858993460
          || v8->guard2[1] != -858993460
          || v8->guard2[2] != -858993460 )
        {
          _RTC_AllocaFailure(retaddr, v8, v9);
        }
        if ( *(_DWORD *)((char *)v8 + v8->allocaSize - 4) != -858993460 )
          _RTC_AllocaFailure(retaddr, v8, v9);
        v8 = v8->next;
        --v9;
      }
      while ( v8 );
    }
  }
}

//----- (004116A0) --------------------------------------------------------
void _RTC_InitBase()
{
  int (*v0)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // eax@2

  if ( !init )
  {
    init = 1;
    v0 = (int (*)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...))j___CRT_RTC_INITW(0, 0, 0, 1, 0);
    j___RTC_SetErrorFuncW(v0);
  }
}
// 41115E: using guessed type int __cdecl j___CRT_RTC_INITW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004116E0) --------------------------------------------------------
int _RTC_Shutdown()
{
  return j___CRT_RTC_INITW(0, 0, 0, 1, 1);
}
// 41115E: using guessed type int __cdecl j___CRT_RTC_INITW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00411700) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __cdecl pre_c_init()
{
  managedapp = check_managed_app();
  ___set_app_type(1);
  __onexitend = EncodePointer((PVOID)0xFFFFFFFF);
  __onexitbegin = __onexitend;
  __fmode = _fmode;
  __commode = _commode;
  j___RTC_Initialize();
  j___setargv();
  if ( !__defaultmatherr )
    ___setusermatherr(j___matherr);
  j___setdefaultprecision();
  if ( __globallocalestatus == -1 )
    __configthreadlocale(-1);
  return 0;
}
// 41173D: write access to const memory at 418314 has been detected
// 41174A: write access to const memory at 418318 has been detected
// 411005: using guessed type int j___setdefaultprecision(void);
// 411140: using guessed type int j___RTC_Initialize(void);
// 417018: using guessed type int __globallocalestatus;
// 41701C: using guessed type int __defaultmatherr;
// 417174: using guessed type int _commode;
// 418310: using guessed type int __cdecl ___set_app_type(_DWORD);
// 41831C: using guessed type int __cdecl ___setusermatherr(_DWORD);
// 418320: using guessed type int __cdecl __configthreadlocale(_DWORD);

//----- (004117B0) --------------------------------------------------------
int pre_cpp_init()
{
  int result; // eax@1

  j__atexit(j___RTC_Terminate);
  startinfo.newmode = _newmode;
  result = ___getmainargs(&argc, &argv, &envp, _dowildcard, &startinfo);
  argret = result;
  if ( result < 0 )
    result = j___amsg_exit(8);
  return result;
}
// 411177: using guessed type int __cdecl j___amsg_exit(_DWORD);
// 41717C: using guessed type int _dowildcard;
// 417180: using guessed type int _newmode;
// 418308: using guessed type int __cdecl ___getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00411820) --------------------------------------------------------
int __cdecl mainCRTStartup()
{
  j____security_init_cookie();
  return _tmainCRTStartup();
}
// 411046: using guessed type int j____security_init_cookie(void);

//----- (00411840) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __cdecl _tmainCRTStartup()
{
  void *lock_free; // [sp+18h] [bp-24h]@4
  void *fiberid; // [sp+1Ch] [bp-20h]@3
  int nested; // [sp+20h] [bp-1Ch]@3

  if ( !_NoHeapEnableTerminationOnCorruption )
    HeapSetInformation(0, HeapEnableTerminationOnCorruption, 0, 0);
  fiberid = j__NtCurrentTeb()->NtTib.StackBase;
  nested = 0;
  while ( 1 )
  {
    lock_free = (void *)InterlockedCompareExchange(&__native_startup_lock, (LONG)fiberid, 0);
    if ( !lock_free )
      break;
    if ( lock_free == fiberid )
    {
      nested = 1;
      break;
    }
    Sleep(0x3E8u);
  }
  if ( __native_startup_state == 1 )
  {
    j___amsg_exit(31);
  }
  else if ( __native_startup_state )
  {
    has_cctor = 1;
  }
  else
  {
    __native_startup_state = 1;
    if ( j___initterm_e(&__xi_a, &__xi_z) )
      return 255;
  }
  if ( __native_startup_state == 1 )
  {
    j___initterm(&__xc_a, &__xc_z);
    __native_startup_state = 2;
  }
  if ( __native_startup_state != 2
    && __CrtDbgReportW(
         2,
         L"f:\\dd\\vctools\\crt_bld\\self_x86\\crt\\src\\crtexe.c",
         476,
         0,
         L"__native_startup_state == __initialized") == 1 )
  {
    __debugbreak();
  }
  if ( !nested )
    InterlockedExchange(&__native_startup_lock, 0);
  if ( *(_DWORD *)__dyn_tls_init_callback && j___IsNonwritableInCurrentImage(__dyn_tls_init_callback) )
    ((void (__stdcall *)(_DWORD, signed int, _DWORD))__dyn_tls_init_callback)(0, 2, 0);
  __CrtSetCheckCount(1);
  ___initenv = envp;
  mainret = j__main();
  if ( !managedapp )
    _exit(mainret);
  if ( !has_cctor )
    __cexit();
  return mainret;
}
// 4119E4: write access to const memory at 4182F4 has been detected
// 417580: invalid function type has been ignored
// 411096: using guessed type int __cdecl j___initterm(_DWORD, _DWORD);
// 411177: using guessed type int __cdecl j___amsg_exit(_DWORD);
// 4111BD: using guessed type int __cdecl j___initterm_e(_DWORD, _DWORD);
// 415860: using guessed type wchar_t aFDdVctoolsCrt_[48];
// 4158D8: using guessed type wchar_t a__native_start[40];
// 417554: using guessed type int __native_startup_state;
// 41757C: using guessed type int _NoHeapEnableTerminationOnCorruption;
// 4182EC: using guessed type int __cdecl __CrtDbgReportW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4182F0: using guessed type int __cdecl __CrtSetCheckCount(_DWORD);

//----- (00411B40) --------------------------------------------------------
_TEB *__cdecl NtCurrentTeb()
{
  return NtCurrentTeb();
}

//----- (00411B50) --------------------------------------------------------
int __cdecl check_managed_app()
{
  int result; // eax@2

  if ( v400000 == 23117 )
  {
    if ( *(_DWORD *)(v40003C + 0x400000) == 17744 )
    {
      if ( *(_WORD *)(v40003C + 4194328) == 267 )
      {
        if ( *(_DWORD *)(v40003C + 4194420) > 0xEu )
          result = *(_DWORD *)(v40003C + 4194536) != 0;
        else
          result = 0;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00411BE0) --------------------------------------------------------
void __cdecl _RTC_Failure(void *retaddr, int errnum)
{
  int v2; // ecx@2

  if ( (unsigned int)errnum > 4 )
  {
    failwithmessage(retaddr, 1, 5, "Unknown Runtime Check Error\n\r");
  }
  else
  {
    v2 = *(&_RTC_ErrorLevels + errnum);
    if ( v2 != -1 )
      failwithmessage(retaddr, v2, errnum, RTC_ErrorMessages[errnum]);
  }
}

//----- (00411C50) --------------------------------------------------------
void __cdecl failwithmessage(void *retaddr, int crttype, int errnum, const char *msg)
{
  unsigned int v4; // eax@3
  char v5; // al@9
  int (__cdecl *v6)(int, wchar_t *, int, wchar_t *, const wchar_t *, int, const wchar_t *); // esi@11
  int v7; // eax@16
  char *v8; // ebx@17
  char *v9; // esi@19
  int (*fn)(int, const char *, int, const char *, const char *, ...); // [sp+10h] [bp-E3Ch]@1
  const wchar_t *msgW; // [sp+18h] [bp-E34h]@5
  int lineNum; // [sp+1Ch] [bp-E30h]@1
  wchar_t msgB[512]; // [sp+20h] [bp-E2Ch]@4
  char srcNameB[778]; // [sp+420h] [bp-A2Ch]@17
  char moduleNameB[778]; // [sp+72Ch] [bp-720h]@19
  wchar_t srcNameW[260]; // [sp+A38h] [bp-414h]@15
  wchar_t moduleNameW[260]; // [sp+C40h] [bp-20Ch]@15

  fn = 0;
  lineNum = (int)_RTC_GetErrorFuncW(retaddr);
  if ( !lineNum )
    fn = _RTC_GetErrorFunc(retaddr);
  v4 = MultiByteToWideChar(0xFDE9u, 0, msg, -1, 0, 0);
  if ( v4 < 0x200 && MultiByteToWideChar(0xFDE9u, 0, msg, -1, msgB, v4) )
    msgW = msgB;
  else
    msgW = L"Runtime Check Error.\n\r Unable to display RTC Message.";
  if ( DebuggerProbe(0x1002u) )
  {
    if ( DebuggerRuntime(errnum, RTC_NoFalsePositives[errnum], retaddr, msgW) )
      return;
    v5 = 0;
  }
  else
  {
    v5 = 1;
  }
  v6 = (int (__cdecl *)(int, wchar_t *, int, wchar_t *, const wchar_t *, int, const wchar_t *))lineNum;
  if ( !fn && !lineNum || v5 && IsDebuggerPresent() )
    goto LABEL_26;
  _RTC_GetSrcLine((char *)retaddr - 5, srcNameW, 0x104u, &lineNum, moduleNameW, 0x104u);
  if ( v6 )
  {
    v7 = v6(crttype, srcNameW, lineNum, moduleNameW, L"Run-Time Check Failure #%d - %s", errnum, msgW);
  }
  else
  {
    v8 = "Unknown Filename";
    if ( WideCharToMultiByte(0xFDE9u, 0, srcNameW, -1, srcNameB, 778, 0, 0) )
      v8 = srcNameB;
    v9 = "Unknown Module Name";
    if ( WideCharToMultiByte(0xFDE9u, 0, moduleNameW, -1, moduleNameB, 778, 0, 0) )
      v9 = moduleNameB;
    v7 = fn(crttype, v8, lineNum, v9, "Run-Time Check Failure #%d - %s", errnum, msg);
  }
  if ( v7 == 1 )
LABEL_26:
    __debugbreak();
}
// 415D70: using guessed type wchar_t aRunTimeCheckFa[32];
// 415DC0: using guessed type wchar_t aRuntimeCheckEr[54];

//----- (00411EF0) --------------------------------------------------------
int __cdecl DebuggerProbe(unsigned int dwLevelRequired)
{
  tagEXCEPTION_VISUALCPP_DEBUG_INFO info; // [sp+10h] [bp-34h]@1
  char bDebuggerListening; // [sp+2Bh] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@1

  bDebuggerListening = 0;
  info.dwType = 4097;
  *(_QWORD *)&info.SetName.szName = __PAIR__(&bDebuggerListening, dwLevelRequired);
  ms_exc.registration.TryLevel = 0;
  RaiseException(0x406D1388u, 0, 6u, &info.dwType);
  return (unsigned __int8)bDebuggerListening;
}

//----- (00411FA0) --------------------------------------------------------
int __cdecl DebuggerRuntime(unsigned int dwErrorNumber, int bRealBug, void *pvReturnAddr, const wchar_t *pwMessage)
{
  tagEXCEPTION_VISUALCPP_DEBUG_INFO info; // [sp+10h] [bp-34h]@1
  char bDebuggerListening; // [sp+2Bh] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@1

  bDebuggerListening = 0;
  info.dwType = 4098;
  *(_QWORD *)&info.SetName.szName = __PAIR__(bRealBug, dwErrorNumber);
  *(_QWORD *)&info.RuntimeError.pvReturnAddress = __PAIR__(&bDebuggerListening, (unsigned int)pvReturnAddr);
  info.RuntimeError.pwRuntimeMessage = pwMessage;
  ms_exc.registration.TryLevel = 0;
  RaiseException(0x406D1388u, 0, 6u, &info.dwType);
  return (unsigned __int8)bDebuggerListening;
}

//----- (00412070) --------------------------------------------------------
void __cdecl _RTC_StackFailure(void *retaddr, const char *varname)
{
  const char *v2; // eax@1
  char *v3; // ebx@4
  int v4; // ecx@4
  char v5; // dl@5
  char v6; // cl@6
  unsigned int v7; // eax@7
  char *v8; // edi@7
  char v9; // cl@8
  unsigned int v10; // eax@9
  char *v11; // edi@9
  char v12; // cl@10
  void *v13; // [sp+0h] [bp-408h]@1
  char msgB[1024]; // [sp+4h] [bp-404h]@4

  v13 = retaddr;
  v2 = varname;
  if ( crttype != -1 )
  {
    if ( *varname && strlen(varname) + 45 <= 0x400 )
    {
      v3 = msgB;
      v4 = 0;
      do
      {
        v5 = stack_premsg[v4];
        msgB[v4++] = v5;
      }
      while ( v5 );
      do
        v6 = *v2++;
      while ( v6 );
      v7 = v2 - varname;
      v8 = (char *)&v13 + 3;
      do
        v9 = (v8++)[1];
      while ( v9 );
      qmemcpy(v8, varname, v7);
      v10 = strlen("' was corrupted.") + 1;
      v11 = (char *)&v13 + 3;
      do
        v12 = (v11++)[1];
      while ( v12 );
      qmemcpy(v11, "' was corrupted.", v10);
    }
    else
    {
      v3 = "Stack corrupted near unknown variable";
    }
    failwithmessage(v13, crttype, 2, v3);
  }
}

//----- (004121B0) --------------------------------------------------------
void __cdecl _RTC_AllocaFailure(void *retaddr, _RTC_ALLOCA_NODE *pn, int num)
{
  int v3; // ebx@1
  HMODULE v4; // eax@2
  FARPROC v5; // eax@3
  int v6; // eax@5
  char msg[244]; // [sp+10h] [bp-140h]@5
  char valbuff[49]; // [sp+104h] [bp-4Ch]@5
  char printbuff[17]; // [sp+138h] [bp-18h]@5

  v3 = dword_417010;
  if ( dword_417010 != -1 )
  {
    v4 = LoadLibraryW(L"user32.dll");
    if ( v4 && (v5 = GetProcAddress(v4, "wsprintfA"), wsprintffp = (int (*)(char *, const char *, ...))v5, pn) && v5 )
    {
      ((void (*)(_DWORD, const char *, ...))v5)(
        msg,
        "%s%s%p%s%ld%s%d%s",
        "Stack area around _alloca memory reserved by this function is corrupted",
        "\nAddress: 0x",
        &pn[1],
        "\nSize: ",
        pn->allocaSize - 36,
        "\nAllocation number within this function: ",
        num,
        "\nData: <");
      getMemBlockDataString(printbuff, valbuff, (char *)&pn[1], pn->allocaSize - 36);
      v6 = lstrlenA(msg);
      wsprintffp(&msg[v6], "%s%s%s%s", printbuff, "> ", valbuff, "\n");
      failwithmessage(retaddr, v3, 4, msg);
    }
    else
    {
      failwithmessage(retaddr, v3, 4, "Stack area around _alloca memory reserved by this function is corrupted\n");
    }
  }
}
// 417164: using guessed type int (*wsprintffp)(char *, const char *, ...);

//----- (00412330) --------------------------------------------------------
void __cdecl getMemBlockDataString(char *printbuff, char *valbuff, char *data, unsigned int datasize)
{
  char *v4; // esi@1
  unsigned int v5; // edi@1
  signed int v6; // eax@1
  unsigned int v7; // ecx@2
  char v8; // bl@5
  char *v9; // [sp+10h] [bp-4h]@1

  v4 = printbuff;
  v9 = valbuff;
  v5 = 0;
  v6 = data - printbuff;
  while ( 1 )
  {
    v7 = datasize;
    if ( datasize >= 0x10 )
      v7 = 16;
    if ( v5 >= v7 )
      break;
    v8 = v4[v6];
    wsprintffp(v9, "%.2X ", (unsigned __int8)v4[v6]);
    v9 += 3;
    v6 = data - printbuff;
    *v4 = v8;
    ++v5;
    ++v4;
  }
  printbuff[v5] = 0;
  *(&valbuff[2 * v5] + v5) = 0;
}
// 417164: using guessed type int (*wsprintffp)(char *, const char *, ...);

//----- (004123C0) --------------------------------------------------------
void __cdecl _RTC_UninitUse(const char *varname)
{
  const char *v1; // eax@1
  char *v2; // ebx@4
  int v3; // ecx@4
  char v4; // dl@5
  char v5; // cl@6
  unsigned int v6; // eax@7
  char *v7; // edi@7
  char v8; // cl@8
  unsigned int v9; // eax@9
  char *v10; // edi@9
  char v11; // cl@10
  char v12; // [sp-1h] [bp-405h]@7
  char msgB[1024]; // [sp+0h] [bp-404h]@4
  void *retaddr; // [sp+408h] [bp+4h]@13

  v1 = varname;
  if ( dword_41700C != -1 )
  {
    if ( varname && strlen(varname) + 58 <= 0x400 )
    {
      v2 = msgB;
      v3 = 0;
      do
      {
        v4 = uninit_premsg[v3];
        msgB[v3++] = v4;
      }
      while ( v4 );
      do
        v5 = *v1++;
      while ( v5 );
      v6 = v1 - varname;
      v7 = &v12;
      do
        v8 = (v7++)[1];
      while ( v8 );
      qmemcpy(v7, varname, v6);
      v9 = strlen("' is being used without being initialized.") + 1;
      v10 = &v12;
      do
        v11 = (v10++)[1];
      while ( v11 );
      qmemcpy(v10, "' is being used without being initialized.", v9);
    }
    else
    {
      v2 = "A variable is being used without being initialized.";
    }
    failwithmessage(retaddr, dword_41700C, 3, v2);
  }
}

//----- (004124F0) --------------------------------------------------------
int __cdecl _RTC_NumErrors()
{
  return 5;
}

//----- (00412500) --------------------------------------------------------
const char *__cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum)
{
  const char *result; // eax@2

  if ( (unsigned int)errnum > 4 )
    result = 0;
  else
    result = RTC_errlist[errnum];
  return result;
}

//----- (00412520) --------------------------------------------------------
int __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int type)
{
  int result; // eax@2

  if ( (unsigned int)errnum > 4 )
  {
    result = -1;
  }
  else
  {
    result = *(&_RTC_ErrorLevels + errnum);
    *(&_RTC_ErrorLevels + errnum) = type;
  }
  return result;
}

//----- (00412550) --------------------------------------------------------
int (*__cdecl _RTC_SetErrorFunc(int (*func)(int, const char *, int, const char *, const char *, ...)))(int, const char *, int, const char *, const char *, ...)
{
  int (*result)(int, const char *, int, const char *, const char *, ...); // eax@1

  result = RTC_ErrorReportFunc;
  RTC_ErrorReportFunc = func;
  RTC_ErrorReportFuncW = 0;
  return result;
}

//----- (00412580) --------------------------------------------------------
int (*__cdecl _RTC_SetErrorFuncW(int (*func)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)
{
  int (*result)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // eax@1

  result = RTC_ErrorReportFuncW;
  RTC_ErrorReportFuncW = func;
  RTC_ErrorReportFunc = 0;
  return result;
}

//----- (004125B0) --------------------------------------------------------
int (*__cdecl _RTC_GetErrorFunc())(int, const char *, int, const char *, const char *, ...)
{
  return RTC_ErrorReportFunc;
}

//----- (004125C0) --------------------------------------------------------
int (*__cdecl _RTC_GetErrorFuncW())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)
{
  return RTC_ErrorReportFuncW;
}

//----- (004125D0) --------------------------------------------------------
int __stdcall __CxxUnhandledExceptionFilter(_EXCEPTION_POINTERS *pPtrs)
{
  if ( pPtrs->ExceptionRecord->ExceptionCode == -529697949
    && pPtrs->ExceptionRecord->NumberParameters == 3
    && (pPtrs->ExceptionRecord->ExceptionInformation[0] == 429065504
     || pPtrs->ExceptionRecord->ExceptionInformation[0] == 429065505
     || pPtrs->ExceptionRecord->ExceptionInformation[0] == 429065506
     || pPtrs->ExceptionRecord->ExceptionInformation[0] == 26820608) )
  {
    terminate();
  }
  return 0;
}

//----- (00412650) --------------------------------------------------------
int __cdecl __CxxSetUnhandledExceptionFilter()
{
  SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (00412670) --------------------------------------------------------
void _setdefaultprecision()
{
  int v0; // eax@1

  v0 = j___controlfp_s(0, 0x10000u, 0x30000u);
  j___invoke_watson_if_error(
    v0,
    L"_controlfp_s(((void *)0), 0x00010000, 0x00030000)",
    L"_setdefaultprecision",
    L"f:\\dd\\vctools\\crt_bld\\self_x86\\crt\\src\\intel\\fp8.c",
    0x1Fu,
    0);
}

//----- (004126C0) --------------------------------------------------------
void __cdecl _invoke_watson_if_error(int _ExpressionError, const wchar_t *_Expression, const wchar_t *_Function, const wchar_t *_File, unsigned int _Line, unsigned int _Reserved)
{
  if ( _ExpressionError )
    j___invoke_watson(_Expression, _Function, _File, _Line, _Reserved);
}
// 411154: using guessed type int __cdecl j___invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00412700) --------------------------------------------------------
int __cdecl _matherr()
{
  return 0;
}

//----- (00412710) --------------------------------------------------------
int __cdecl _setargv()
{
  return 0;
}

//----- (00412720) --------------------------------------------------------
int (*_RTC_Initialize())(void)
{
  int (**v0)(void); // esi@1
  int (*result)(void); // eax@1

  v0 = (int (**)(void))&unk_416660;
  result = (int (*)(void))&unk_416660;
  if ( &unk_416660 < &__rtc_izz )
  {
    do
    {
      result = *v0;
      if ( *v0 )
        result = (int (*)(void))result();
      ++v0;
    }
    while ( v0 < (int (**)(void))&__rtc_izz );
  }
  return result;
}

//----- (00412750) --------------------------------------------------------
int (*_RTC_Terminate())(void)
{
  int (**v0)(void); // esi@1
  int (*result)(void); // eax@1

  v0 = (int (**)(void))&unk_41696C;
  result = (int (*)(void))&unk_41696C;
  if ( &unk_41696C < &__rtc_tzz )
  {
    do
    {
      result = *v0;
      if ( *v0 )
        result = (int (*)(void))result();
      ++v0;
    }
    while ( v0 < (int (**)(void))&__rtc_tzz );
  }
  return result;
}

//----- (00412780) --------------------------------------------------------
int (__cdecl *__cdecl _onexit(int (__cdecl *func)()))()
{
  int (__cdecl *result)(); // eax@2
  PVOID v2; // eax@3
  void (__cdecl **onexitend)(); // [sp+10h] [bp-24h]@3
  int (__cdecl *retval)(); // [sp+14h] [bp-20h]@3
  void (__cdecl **onexitbegin)(); // [sp+18h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@3

  if ( DecodePointer(__onexitbegin) == (PVOID)-1 )
  {
    result = __onexit(func);
  }
  else
  {
    j___lock(8);
    ms_exc.registration.TryLevel = 0;
    onexitbegin = (void (__cdecl **)())DecodePointer(__onexitbegin);
    onexitend = (void (__cdecl **)())DecodePointer(__onexitend);
    v2 = EncodePointer(func);
    retval = (int (__cdecl *)())j____dllonexit(v2);
    __onexitbegin = EncodePointer(onexitbegin);
    __onexitend = EncodePointer(onexitend);
    ms_exc.registration.TryLevel = -2;
    j___unlock(8);
    result = retval;
  }
  return result;
}
// 411073: using guessed type int __cdecl j___lock(_DWORD);
// 41111D: using guessed type int __cdecl j___unlock(_DWORD);
// 4111B3: using guessed type int __stdcall j____dllonexit(_DWORD);

//----- (004128B0) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *func)())
{
  return (j___onexit((int (__cdecl *)())func) != 0) - 1;
}

//----- (004128F0) --------------------------------------------------------
unsigned int __security_init_cookie()
{
  unsigned int result; // eax@2
  _LARGE_INTEGER perfctr; // [sp+0h] [bp-18h]@4
  unsigned int cookie; // [sp+Ch] [bp-Ch]@4
  FT systime; // [sp+10h] [bp-8h]@1

  systime.ft_scalar = 0i64;
  if ( __security_cookie != -1153374642 && (result = __security_cookie & 0xFFFF0000) != 0 )
  {
    __security_cookie_complement = ~__security_cookie;
  }
  else
  {
    GetSystemTimeAsFileTime((LPFILETIME)&systime);
    cookie = systime.ft_struct.dwHighDateTime ^ systime.ft_struct.dwLowDateTime;
    cookie ^= GetCurrentProcessId();
    cookie ^= GetCurrentThreadId();
    cookie ^= GetTickCount();
    QueryPerformanceCounter(&perfctr);
    result = perfctr.LowPart ^ cookie;
    cookie ^= perfctr.LowPart;
    cookie ^= perfctr.HighPart;
    if ( cookie == -1153374642 )
    {
      cookie = -1153374641;
    }
    else if ( !(cookie & 0xFFFF0000) )
    {
      result = cookie | ((cookie | 0x4711) << 16);
      cookie |= (cookie | 0x4711) << 16;
    }
    __security_cookie = cookie;
    __security_cookie_complement = ~cookie;
  }
  return result;
}
// 417030: using guessed type int __security_cookie_complement;

//----- (00412A30) --------------------------------------------------------
int __cdecl _ValidateImageBase(char *pImageBase)
{
  int result; // eax@2
  _IMAGE_NT_HEADERS *pNTHeader; // [sp+0h] [bp-Ch]@3

  if ( *(_WORD *)pImageBase == 23117 )
  {
    pNTHeader = (_IMAGE_NT_HEADERS *)&pImageBase[*((_DWORD *)pImageBase + 15)];
    if ( pNTHeader->Signature == 17744 )
      result = pNTHeader->OptionalHeader.Magic == 267;
    else
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00412AB0) --------------------------------------------------------
_IMAGE_SECTION_HEADER *__cdecl _FindPESection(char *pImageBase, unsigned int rva)
{
  _IMAGE_SECTION_HEADER *pSection; // [sp+0h] [bp-Ch]@1
  unsigned int iSection; // [sp+4h] [bp-8h]@1
  _IMAGE_NT_HEADERS *pNTHeader; // [sp+8h] [bp-4h]@1

  pNTHeader = (_IMAGE_NT_HEADERS *)&pImageBase[*((_DWORD *)pImageBase + 15)];
  iSection = 0;
  pSection = (_IMAGE_SECTION_HEADER *)((char *)&pNTHeader->OptionalHeader + pNTHeader->FileHeader.SizeOfOptionalHeader);
  while ( iSection < pNTHeader->FileHeader.NumberOfSections )
  {
    if ( rva >= pSection->VirtualAddress && rva < pSection->Misc.PhysicalAddress + pSection->VirtualAddress )
      return pSection;
    ++iSection;
    ++pSection;
  }
  return 0;
}

//----- (00412B50) --------------------------------------------------------
int __cdecl _IsNonwritableInCurrentImage(char *pTarget)
{
  int result; // eax@2
  _IMAGE_SECTION_HEADER *pSection; // [sp+28h] [bp-20h]@3

  if ( j___ValidateImageBase((char *)0x400000) )
  {
    pSection = j___FindPESection((char *)0x400000, (unsigned int)(pTarget - 0x400000));
    if ( pSection )
      result = (pSection->Characteristics & 0x80000000) == 0;
    else
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00412CC0) --------------------------------------------------------
int __cdecl _except_handler4(_EXCEPTION_RECORD *ExceptionRecord, _EXCEPTION_REGISTRATION_RECORD *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext)
{
  return j___except_handler4_common(
           &__security_cookie,
           __security_check_cookie,
           ExceptionRecord,
           EstablisherFrame,
           ContextRecord,
           DispatcherContext);
}
// 411190: using guessed type int __cdecl j___except_handler4_common(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00412D00) --------------------------------------------------------
int __cdecl _RTC_GetSrcLine(char *address, wchar_t *source, unsigned int sourcelen, int *pline, wchar_t *moduleName, unsigned int modulelen)
{
  wchar_t *v6; // edx@1
  char *v7; // esi@1
  char *v8; // esi@1
  int v10; // eax@5
  char *v11; // eax@6
  unsigned int v12; // ecx@7
  char *v13; // eax@7
  unsigned int v14; // esi@7
  unsigned int v15; // edi@7
  unsigned int v16; // ebx@7
  int v17; // ebx@12
  HMODULE v18; // eax@14
  FARPROC v19; // eax@17
  unsigned int *v20; // esi@17
  unsigned int (__thiscall *v21)(PDB *); // edx@20
  SIZE_T v22; // ST24_4@34
  HANDLE v23; // eax@34
  unsigned int *v24; // eax@34
  unsigned int v25; // edi@36
  unsigned int i; // eax@37
  HANDLE v27; // eax@42
  int v28; // [sp-8h] [bp-50h]@3
  int v29; // [sp-4h] [bp-4Ch]@3
  int v30; // [sp+0h] [bp-48h]@0
  _MEMORY_BASIC_INFORMATION mbi; // [sp+4h] [bp-44h]@1
  int ec; // [sp+20h] [bp-28h]@18
  unsigned int idFile; // [sp+24h] [bp-24h]@35
  unsigned int cbBlk; // [sp+28h] [bp-20h]@26
  int res; // [sp+2Ch] [bp-1Ch]@20
  DBI *pdbi; // [sp+30h] [bp-18h]@21
  unsigned int offBlk; // [sp+34h] [bp-14h]@26
  PDB *ppdb; // [sp+38h] [bp-10h]@18
  Mod *pmod; // [sp+3Ch] [bp-Ch]@22
  unsigned int cLines; // [sp+40h] [bp-8h]@26
  EnumLines *penum; // [sp+44h] [bp-4h]@23

  v6 = source;
  v7 = address;
  *pline = 0;
  v8 = v7 - 1;
  *v6 = 0;
  if ( !VirtualQuery(v8, &mbi, 0x1Cu) )
    return 0;
  if ( !GetModuleFileNameW((HMODULE)mbi.AllocationBase, moduleName, modulelen) )
    return 0;
  if ( *(_WORD *)mbi.AllocationBase != 23117 )
    return 0;
  v10 = *((_DWORD *)mbi.AllocationBase + 15);
  if ( v10 <= 0 )
    return 0;
  v11 = (char *)mbi.AllocationBase + v10;
  if ( *(_DWORD *)v11 != 17744 )
    return 0;
  v12 = *((_WORD *)v11 + 3);
  v13 = &v11[*((_WORD *)v11 + 10) + 36];
  v14 = v8 - mbi.AllocationBase;
  v15 = 0;
  v16 = 0;
  if ( v12 )
  {
    do
    {
      if ( v14 >= *(_DWORD *)v13 )
      {
        v15 = v14 - *(_DWORD *)v13;
        if ( v14 < *((_DWORD *)v13 - 1) )
          break;
      }
      ++v16;
      v13 += 40;
    }
    while ( v16 < v12 );
  }
  if ( v16 == v12 )
    return 0;
  v17 = v16 + 1;
  if ( PDBOK )
  {
    v18 = mspdb;
  }
  else
  {
    if ( mspdb )
      return 0;
    v18 = GetPdbDll();
    mspdb = v18;
    if ( !v18 )
      return 0;
    PDBOK = 1;
  }
  v19 = GetProcAddress(v18, "PDBOpenValidate5");
  v20 = 0;
  if ( !v19
    || !((int (__cdecl *)(wchar_t *, _DWORD, _DWORD, _DWORD, int *, _DWORD, _DWORD, PDB **))v19)(
          moduleName,
          0,
          0,
          0,
          &ec,
          0,
          0,
          &ppdb) )
  {
    return 0;
  }
  v21 = ppdb->vfptr->QueryInterfaceVersion;
  res = 0;
  if ( ((int (__stdcall *)(int, int))v21)(v28, v29) == 20030901
    && ((int (__stdcall *)(_DWORD, const char *, DBI **))ppdb->vfptr->OpenDBI)(0, "r", &pdbi) )
  {
    if ( ((int (__stdcall *)(int, unsigned int, Mod **, _DWORD, _DWORD, _DWORD))pdbi->vfptr->QueryModFromAddr)(
           v17,
           v15,
           &pmod,
           0,
           0,
           0) )
    {
      penum = 0;
      if ( (unsigned __int8)((int (__stdcall *)(EnumLines **))pmod->vfptr->GetEnumLines)(&penum) && penum )
      {
        if ( ((int (*)(void))penum->vfptr->next)() )
        {
          while ( (unsigned __int8)((int (__stdcall *)(_DWORD, unsigned int *, char **, unsigned int *, unsigned int *, _DWORD))penum->vfptr[1].release)(
                                     0,
                                     &offBlk,
                                     &address,
                                     &cbBlk,
                                     &cLines,
                                     0) )
          {
            if ( (unsigned __int16)address == v17 && offBlk <= v15 && v15 < cbBlk + offBlk )
            {
              if ( !cLines )
                break;
              if ( cLines >= 0x1FFFFFFF )
                break;
              v22 = 8 * cLines;
              v23 = GetProcessHeap();
              v24 = (unsigned int *)HeapAlloc(v23, 0, v22);
              v20 = v24;
              if ( !v24 )
                break;
              if ( (unsigned __int8)((int (__stdcall *)(unsigned int *, _DWORD, _DWORD, _DWORD, unsigned int *, unsigned int *))penum->vfptr[1].release)(
                                      &idFile,
                                      0,
                                      0,
                                      0,
                                      &cLines,
                                      v24) )
              {
                v25 = v15 - offBlk;
                if ( v25 >= *v20 )
                {
                  for ( i = 1; i < cLines; ++i )
                  {
                    if ( v25 < v20[2 * i] )
                      break;
                  }
                  *pline = v20[2 * i - 1] & 0xFFFFFF;
                  if ( (unsigned __int8)((int (__stdcall *)(unsigned int, wchar_t *, unsigned int *, _DWORD, _DWORD, _DWORD))pmod->vfptr->QueryFileNameInfo)(
                                          idFile,
                                          source,
                                          &sourcelen,
                                          0,
                                          0,
                                          0) )
                    res = 1;
                }
              }
              goto DONE5;
            }
            if ( !((int (*)(void))penum->vfptr->next)() )
              goto DONE5;
          }
        }
        else
        {
DONE5:
          v27 = GetProcessHeap();
          HeapFree(v27, 0, v20);
        }
        ((void (*)(void))penum->vfptr->release)();
      }
      ((void (*)(void))pmod->vfptr->Close)();
    }
    ((void (*)(void))pdbi->vfptr->Close)();
  }
  ((void (__stdcall *)(int, void *, void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, int, unsigned int, unsigned int, int, DBI *, unsigned int, PDB *))ppdb->vfptr->Close)(
    v30,
    mbi.BaseAddress,
    mbi.AllocationBase,
    mbi.AllocationProtect,
    mbi.RegionSize,
    mbi.State,
    mbi.Protect,
    mbi.Type,
    ec,
    idFile,
    cbBlk,
    res,
    pdbi,
    offBlk,
    ppdb);
  return res;
}

//----- (00413070) --------------------------------------------------------
HINSTANCE__ *__cdecl GetPdbDll()
{
  HINSTANCE__ *result; // eax@2
  HMODULE v1; // esi@4
  FARPROC v2; // ebx@6
  FARPROC v3; // edi@7
  int v4; // ebx@11
  unsigned int v5; // eax@15
  wchar_t *v6; // eax@20
  unsigned int type; // [sp+0h] [bp-21Ch]@11
  int (__stdcall *pfnRegOpenKeyExW)(HKEY__ *, const wchar_t *, unsigned int, unsigned int, HKEY__ **); // [sp+4h] [bp-218h]@5
  HKEY__ *hkey; // [sp+8h] [bp-214h]@8
  unsigned int cb; // [sp+Ch] [bp-210h]@11
  wchar_t buf[260]; // [sp+10h] [bp-20Ch]@11

  if ( alreadyTried )
    return 0;
  alreadyTried = 1;
  result = LoadLibraryW(mspdbName);
  if ( !result )
  {
    result = LoadLibraryW(L"ADVAPI32.DLL");
    v1 = result;
    if ( result )
    {
      result = (HINSTANCE__ *)GetProcAddress(result, "RegOpenKeyExW");
      pfnRegOpenKeyExW = (int (__stdcall *)(HKEY__ *, const wchar_t *, unsigned int, unsigned int, HKEY__ **))result;
      if ( result )
      {
        v2 = GetProcAddress(v1, "RegQueryValueExW");
        if ( !v2 )
          return 0;
        v3 = GetProcAddress(v1, "RegCloseKey");
        if ( !v3 )
          return 0;
        if ( pfnRegOpenKeyExW(
               (HKEY__ *)-2147483646,
               L"SOFTWARE\\Microsoft\\VisualStudio\\10.0\\Setup\\VS",
               0,
               1u,
               &hkey) )
        {
          FreeLibrary(v1);
          return 0;
        }
        cb = 520;
        v4 = ((int (__stdcall *)(HKEY__ *, const wchar_t *, _DWORD, unsigned int *, wchar_t *, unsigned int *))v2)(
               hkey,
               L"EnvironmentDirectory",
               0,
               &type,
               buf,
               &cb);
        ((void (__stdcall *)(HKEY__ *))v3)(hkey);
        FreeLibrary(v1);
        if ( v4 )
          return 0;
        if ( type != 1 )
          return 0;
        if ( cb & 1 )
          return 0;
        if ( cb >> 1 < 2 )
          return 0;
        v5 = (cb >> 1) - 1;
        if ( buf[v5] )
          return 0;
        if ( *((_WORD *)&cb + v5 + 1) != 92 )
          buf[v5++] = 92;
        if ( -1 - v5 < 0xE || v5 + 13 > 0x104 )
          return 0;
        v6 = &buf[v5];
        *(_DWORD *)v6 = *(_DWORD *)mspdbName;
        *((_DWORD *)v6 + 1) = *(_DWORD *)&mspdbName[2];
        *((_DWORD *)v6 + 2) = *(_DWORD *)&mspdbName[4];
        *((_DWORD *)v6 + 3) = *(_DWORD *)&mspdbName[6];
        *((_DWORD *)v6 + 4) = *(_DWORD *)&mspdbName[8];
        *((_DWORD *)v6 + 5) = *(_DWORD *)&mspdbName[10];
        v6[12] = mspdbName[12];
        result = LoadLibraryW(buf);
      }
    }
  }
  return result;
}
// 416284: using guessed type wchar_t aEnvironmentdir[21];

//----- (00413320) --------------------------------------------------------
BOOL __usercall __noreturn __report_gsfailure@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4@<ebx>, unsigned int a5@<edi>, unsigned int a6@<esi>, char a7)
{
  unsigned int v7; // et0@1
  HANDLE v8; // eax@3
  unsigned int vars0; // [sp+328h] [bp+0h]@0
  void *retaddr; // [sp+32Ch] [bp+4h]@1

  GS_ContextRecord.Eax = a1;
  GS_ContextRecord.Ecx = a3;
  GS_ContextRecord.Edx = a2;
  GS_ContextRecord.Ebx = a4;
  GS_ContextRecord.Esi = a6;
  GS_ContextRecord.Edi = a5;
  LOWORD(GS_ContextRecord.SegSs) = __SS__;
  LOWORD(GS_ContextRecord.SegCs) = __CS__;
  LOWORD(GS_ContextRecord.SegDs) = __DS__;
  LOWORD(GS_ContextRecord.SegEs) = __ES__;
  LOWORD(GS_ContextRecord.SegFs) = __FS__;
  LOWORD(GS_ContextRecord.SegGs) = __GS__;
  v7 = __readeflags();
  GS_ContextRecord.EFlags = v7;
  GS_ContextRecord.Ebp = vars0;
  GS_ContextRecord.Eip = (unsigned int)retaddr;
  GS_ContextRecord.Esp = (unsigned int)&a7;
  GS_ContextRecord.ContextFlags = 65537;
  GS_ExceptionRecord.ExceptionAddress = retaddr;
  GS_ExceptionRecord.ExceptionCode = -1073740791;
  GS_ExceptionRecord.ExceptionFlags = 1;
  DebuggerWasPresent = IsDebuggerPresent();
  j___crt_debugger_hook(1);
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(&GS_ExceptionPointers);
  if ( !DebuggerWasPresent )
    j___crt_debugger_hook(1);
  v8 = GetCurrentProcess();
  return TerminateProcess(v8, 0xC0000409);
}
// 4110D2: using guessed type int __cdecl j___crt_debugger_hook(_DWORD);
// 417030: using guessed type int __security_cookie_complement;

// ALL OK, 45 function(s) have been successfully decompiled
